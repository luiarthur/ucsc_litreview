#include "mcmc.h"
#include "Data.h"
#include "Prior_addon.h"
#include "State_addon.h"
#include "Locked_addon.h"

#include "util.h"
#include "update_theta.h"
#include "compute_loglike.h"

#include <omp.h>           // shared memory multicore parallelism

using namespace Rcpp;

// TODO. Remove all colon after `at` param.

//' Cytof Model for fixed K
//' TODO: add descriptions for params
//' @param y  A list of NumericMatrix with same number of columns.
//' @param B  (int). Number of MCMC samples (post burn-in).
//' @param burn  (int). Burn in iterations in MCMC.
//' @param prior_ls  Priors. Generated by `gen_default_prior`.
//' @param locked_ls  Parameters that are not random. Generated by `gen_default_locked`.
//' @param init_ls  Initial values. Generated by `gen_default_init`.
//' @param thin  (int). Thinning.
//' @param thin_some  (int). Thinning amount for some parameters.
//' @param compute_loglike_every  (int). Frequency of computing loglike.
//' @param normalize_loglike  (bool). Whether the log-likelihood should be normalized.
//' @export
// [[Rcpp::export]]
std::vector<List> fit_cytof_cpp(
  const std::vector<Rcpp::NumericMatrix> &y, int B, int burn,
  List prior_ls, List locked_ls, List init_ls,
  int thin=1, int thin_some=1,
  int compute_loglike_every=1, int print_freq=10, int ncores=1,
  bool show_timings=false, 
  bool normalize_loglike=false) {

  const Prior prior = gen_prior_obj(prior_ls);
  const Locked locked= gen_locked_obj(locked_ls);
  const Data data = gen_data_obj(y);
  State init= gen_state_obj(init_ls);
  const int I = data.I;
  const int J = data.J;

  
  // update function
  auto update = [&](State &state) {
    for (int t=0; t<thin; t++) {
      update_theta(state, data, prior, locked, thin_some);
    }
  };

  // accumulater for sum of missing y's
  std::vector<Rcpp::NumericMatrix> missing_y_sum(I);
  for (int i=0; i<I; i++) {
    missing_y_sum[i] = Rcpp::NumericMatrix(data.N[i], J);
  }
  
  // output 
  std::vector<List> out(B);

  // assign function
  auto assign_to_out = [&](const State &state, int i) {
    // only do the following after burn-in
    if (i - burn >= 0) {
      // loglike
      double ll;
      // update loglike
      if ( (i-burn+1) % compute_loglike_every == 0 || i == burn ) {
        ll = compute_loglike(state, data, prior, normalize_loglike);
      }

      // update missing_y_sum
      for (int s=0; s<I; s++) {
        missing_y_sum[s] += state.missing_y[s];
      }

      // TODO: profile the speed of these operations
      out[i - burn] = List::create(
        //Named("beta_0") = state.beta_0,
        //Named("beta_1") = state.beta_1,
        Named("alpha") = state.alpha
        //Named("ll") = ll
      );
    }

    // Append `missing_y_mean` and `missing_y_last` to last iteration of MCMC
    if (i == B + burn - 1) {
      auto missing_y_mean = init.missing_y;
      for (int s=0; s<I; s++) {
        missing_y_mean[s] = missing_y_sum[s] / B;
      }
      out[B-1]["missing_y_mean"] = missing_y_mean;
      out[B-1]["missing_y_last"] = state.missing_y;
    }
  };

  omp_set_num_threads(ncores);

  mcmc::gibbs<State>(init, update, assign_to_out, B, burn, print_freq);
  
  return out;  
}  
